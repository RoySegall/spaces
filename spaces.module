<?php

/**
 * @file
 * Main functionality file for the spaces module.
 */

/**
 * Implements hook_init().
 */
function spaces_init() {
  global $conf;
  $debug = FALSE;
  if ($debug) {
    // Create a space to a article node.
    $space = spaces_create('article');
    $space->entity_id = 1;
    $space->entity_type = 'node';
    $space->settings['variables'] = array('site_name' => 'foo');
    $space->save();
  }

  $menu = menu_get_item();
//  if (!empty($menu['load_functions']) && $menu['load_functions'][1] == 'node_load') {
//    $spaces = spaces_load_entity_spaces('node', $menu['original_map'][1]);
//
//    foreach ($spaces as $space) {
//      // Overriding the $conf values with the space values.
//      $conf = drupal_array_merge_deep($conf, $space->settings['variables']);
//    }
//  }

  // Get the context.
  $context = spaces_context();
}

/**
 * Implements hook_menu().
 */
function spaces_menu() {
  $items = array();

  return $items;
}

/**
 * Implements hook_permission().
 */
function spaces_permission() {
  return array(
    'foo' => array(
      'title' => t('Bar'),
      'description' => t('bar'),
    ),
  );
}

/**
 * Get the current context.
 */
function spaces_context() {
  $context = &drupal_static(__FUNCTION__, FALSE);

  if (!empty($context)) {
    return $context;
  }

  $context = spaces_determine_context();

  return $context;
}

/**
 * Determine the context of the current space.
 *
 * @param $item
 *  Optional; A menu item that context should be extracted from. If empty
 *  defaults to the current menu item by using menu_get_item().
 *
 * @return
 *  The current context of the user.
 */
function spaces_determine_context($item = NULL) {
  if (!$item) {
    $item = menu_get_item();
  }

  // Get the all the determine context plugins.
  $plugins = spaces_get_spaces_styles();
  $method = NULL;

  foreach ($plugins as $plugin) {
    if (!empty($plugin['path'])) {
      foreach ($plugin['path'] as $path) {
        if (strpos($item['path'], $path) === 0) {
          $method = $plugin;
          $invoke = TRUE;
          // Path matches, so we can break.
          break;
        }
      }
    }
    else {
      // Context isn't determined by the menu item.
      $invoke = TRUE;
    }
  }

  // Get the first plugin provider.
  if (!empty($method)) {
    $value = call_user_func($method['function'], $item);

    return reset($value);
  }
}

/**
 * Implements hook_ctools_plugin_api().
 */
function spaces_ctools_plugin_api($module, $api) {
  if ($module == 'spaces' && $api == 'spaces_app') {
    return array('version' => 1);
  }
}

/**
 * Implements hook_ctools_plugin_type().
 */
function spaces_ctools_plugin_type() {
  $plugins['spaces_app'] = array(
    'classes' => array('class'),
    'process' => 'spaces_plugin_process',
  );
  return $plugins;
}

/**
 * Add defaults values to the notifier plugins.
 *
 * - 'description': The description of the plugin.
 */
function spaces_plugin_process(&$plugin, $info) {
  $plugin += array(
    'description' => '',
    'options' => array(),
  );
}

/**
 * Implements hook_ctools_plugin_directory().
 */
function spaces_ctools_plugin_directory($module, $plugin) {
  if ($module == 'spaces') {
    return 'plugins/' . $plugin;
  }
}

/**
 * Helper function to include CTools plugins and get a notifier plugin.
 *
 * @param $plugin_name
 *   The plugin that should be loaded.
 *
 * @return array
 */
function spaces_get_spaces_style($style_name) {
  ctools_include('plugins');
  return ctools_get_plugins('spaces', 'spaces_app', $style_name);
}

/**
 * Helper function to include CTools plugins and get all notifier plugins.
 */
function spaces_get_spaces_styles() {
  ctools_include('plugins');
  return ctools_get_plugins('spaces', 'spaces_app');
}

/**
 * Implements hook_entity_info().
 */
function spaces_entity_info() {
  $return = array(
    'space' => array(
      'label' => t('Space'),
      'controller class' => 'EntityAPIController',
      'entity class' => 'Space',
      'base table' => 'space',
      'fieldable' => TRUE,
      'entity keys' => array(
        'id' => 'id',
        'label' => 'title',
        'bundle' => 'type',
      ),
      'bundle keys' => array(
        'bundle' => 'type',
      ),
    ),
  );

  return $return;
}

/**
 * Create a base object of the space app entity.
 *
 * @param $type
 *  The type of the space.
 * @param $values
 *  Overriding the entity settings.
 * @return Space
 */
function spaces_create($type, $values = array()) {
  $values['type'] = $type;
  return entity_create('space', $values);
}

/**
 * Loading a single spaces instance.
 *
 * @param $id
 *  The identifier of the space instance.
 * @return Space
 *  A space object.
 */
function spaces_load($id) {
  $spaces = spaces_load_multiple(array($id));
  return reset($spaces);
}

/**
 * Loading multiple spaces instances.
 *
 * @param $ids
 *  Array of spaces ID's.
 */
function spaces_load_multiple($ids) {
  return entity_load('space', $ids);
}

/**
 * Loading spaces referenced to an entity.
 *
 * @param $entity_type
 *  The entity type.
 * @param $data
 *  The entity object or identifier.
 *
 * @return
 *  All the referenced spaces.
 */
function spaces_load_entity_spaces($entity_type, $data) {
  $wrapper = entity_metadata_wrapper($entity_type, $data);

  // Load all the spaces for the node the user watching.
  $query = new entityFieldQuery();
  $result = $query
    ->entityCondition('entity_type', 'space')
    ->propertyCondition('entity_id', $wrapper->getIdentifier())
    ->propertyCondition('entity_type', $wrapper->type())
    ->propertyCondition('type', $wrapper->getBundle())
//    ->propertyCondition('status', 1)
    ->execute();

  if (empty($result['space'])) {
    return array();
  }

  return spaces_load_multiple(array_keys($result['space']));
}
